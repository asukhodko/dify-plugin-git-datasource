## Пользовательские истории

Чтобы лучше понять желаемое поведение плагина с точки зрения пользователя Dify, рассмотрим несколько типовых сценариев:

- **История 1: Первичное добавление репозитория.** _Как пользователь Dify, я хочу подключить Git-репозиторий как источник знаний._ На странице создания базы знаний я выбираю опцию “Sync from website” (синхронизация с сайта/репо) и указываю URL моего репозитория. После ввода необходимых данных (например, ключа доступа) я запускаю синхронизацию. **Ожидаемое поведение:** плагин автоматически склонирует репозиторий и извлечёт все файлы. В результате я увижу, что в базу знаний добавлены документы, соответствующие каждому файлу в репозитории – они отображаются в списке документов с названиями файлов, а их содержимое уже разложено на чанки для поиска.
    
- **История 2: Обновление репозитория с новыми данными.** _Как пользователь, я хочу обновлять базу знаний при изменениях в репозитории._ Предположим, я добавил новые файлы в Git или отредактировал/удалил существующие. В Dify я перехожу в базу знаний и нажимаю “Sync” для данного источника. **Ожидаемое поведение:** плагин подтянет последние изменения (git pull), сравнит содержимое. Новые файлы появятся как новые документы базы знаний. Изменённые файлы – обновятся (их документы пересчитаются, получат новую версию контента). Файлы, которые я удалил из репозитория, будут отмечены в Dify как удалённые (например, **помечены статусом “orphaned”** и исключены из поиска)[docs.dify.ai](https://docs.dify.ai/en/use-dify/knowledge/create-knowledge/import-text-data/sync-from-notion#:~:text=Synchronizing%20Notion%20Data). Таким образом, моя база знаний всегда соответствует актуальному состоянию репозитория.
    
- **История 3: Фильтрация и структура документов.** _Как пользователь, я хочу контролировать, какие файлы из репозитория попадут в базу знаний._ При подключении плагина у меня есть возможность указать параметры, например, включать ли определённые пути или игнорировать файлы по шаблону (например, `*.log` или папку `node_modules`). **Ожидаемое поведение:** плагин, выполняя краулинг, учитывает эти настройки – например, он пропустит папки, перечисленные в исключениях (по аналогии с опциями Firecrawl “Exclude paths” и “Include only” для веб-краулера[dify.ai](https://dify.ai/blog/dify-ai-blog-integrated-with-firecrawl#:~:text=Easy%20Setup)[dify.ai](https://dify.ai/blog/dify-ai-blog-integrated-with-firecrawl#:~:text=The%20%27Crawl%20sub,you%20to)). В результате в базу знаний попадут только релевантные файлы, а лишний “мусор” будет проигнорирован. Также каждый документ будет содержать указание пути или ссылки на исходный файл (например, поле “source_url” у каждого документа – возможно, ссылка на файл в интерфейсе GitLab/GitHub или просто путь в репо), чтобы я мог идентифицировать откуда информация.
    
- **История 4: Разделение крупных файлов.** _Как пользователь, я хочу, чтобы даже большие файлы из репозитория были корректно обработаны._ Когда плагин импортирует файл, Dify выполнит его разбиение на_chunks согласно настройкам (например, по умолчанию 2000 символов или выбранный режим chunking). **Ожидаемое поведение:** после синхронизации, если у меня был большой Markdown-документ в репозитории, Dify разбивает его на несколько смысловых чанков, но все они привязаны к одному документу (файлу). Я могу настроить глубину разбиения или режим (например, иерархический “Parent-child” или просто по длине), и эти настройки применятся к каждому новому документу. Таким образом, плагин обеспечивает перенесение содержимого, а Dify – автоматическую нарезку, и я получаю хорошо индексируемую информацию.
    
- **История 5: Разные способы доступа к репозиторию.** _Как пользователь, я хочу подключать разные репозитории, независимо от способа доступа._ Например, у меня есть публичный репозиторий на GitHub – я просто ввожу ссылку `https://github.com/user/repo.git` без дополнительных ключей, и плагин успешно его загружает. В другом случае у меня приватный репозиторий – я выбираю способ SSH-доступа, предварительно добавив свой SSH-ключ в настройки плагина, либо указываю HTTPS URL вместе с токеном. **Ожидаемое поведение:** плагин гибко обрабатывает оба случая: при SSH – использует ключ для аутентификации, при HTTPS – токен, при локальном репо – просто читает файлы напрямую. Для меня, как для пользователя, процесс максимально прост: если нужны креденшиалы, Dify запросит их при подключении провайдера (например, OAuth для GitHub не используется в этом сценарии, вместо этого – прямой ключ). После настройки я ожидаю, что плагин **автоматически получит весь контент** репозитория вне зависимости от способа подключения.
